<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>–ü—Ä–∏–∫–ª—é—á–µ–Ω–∏—è –Æ–Ω–æ–≥–æ –ü–∏—Ä–∞—Ç–∞ –ß–∏–±–∏–∫–∞</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Comfortaa:wght@700&family=Kelly+Slab&display=swap');

        /* –°–±—Ä–æ—Å –∏ –±–∞–∑–æ–≤—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ */
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a0a00;
            font-family: 'Comfortaa', cursive;
            user-select: none;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            position: fixed; /* –§–∏–∫—Å–∏—Ä—É–µ–º body, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Å–∫—Ä–æ–ª–ª–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã */
            width: 100%;
            height: 100%;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1;
        }

        canvas {
            background: #222;
            cursor: pointer;
            display: block;
        }

        /* UI —Å–ª–æ–π –ø–æ–≤–µ—Ä—Ö –∫–∞–Ω–≤–∞—Å–∞ */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        .top-bar {
            padding: 2vmin;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
        }

        .alphabet-progress {
            background: rgba(0, 0, 0, 0.7);
            padding: 1.5vmin 2vmin;
            border-radius: 15px;
            border: 2px solid #ffd700;
            color: white;
            max-width: 60%;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5vmin;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        .letter-slot {
            font-size: 2.5vmin;
            opacity: 0.3;
            transition: all 0.3s;
        }

        .letter-slot.active {
            opacity: 1;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            transform: scale(1.2);
        }

        .right-controls {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 1.5vmin;
            pointer-events: auto;
        }

        .lives {
            font-size: 4vmin;
            color: #ff4444;
            filter: drop-shadow(0 0 5px black);
        }

        .pause-btn {
            background: rgba(255, 215, 0, 0.2);
            border: 2px solid #ffd700;
            color: #ffd700;
            border-radius: 20px;
            padding: 1vmin 2.5vmin;
            font-size: 2.5vmin;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Kelly Slab', serif;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .pause-btn:hover {
            background: rgba(255, 215, 0, 0.5);
            transform: scale(1.05);
        }

        /* –ü–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–µ —Å–ª–æ–∏ (–ú–µ–Ω—é, –ö–∞—Ç—Å—Ü–µ–Ω—ã) */
        .overlay-screen {
            position: fixed; /* –ò—Å–ø–æ–ª—å–∑—É–µ–º fixed –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ–≥–æ –ø–æ–∫—Ä—ã—Ç–∏—è viewport */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 100;
            pointer-events: all;
            overflow-y: auto; /* –†–∞–∑—Ä–µ—à–∞–µ–º —Å–∫—Ä–æ–ª–ª, –µ—Å–ª–∏ –∫–æ–Ω—Ç–µ–Ω—Ç –Ω–µ –≤–ª–µ–∑–∞–µ—Ç */
            overflow-x: hidden;
            /* –£—á–µ—Ç "—á–µ–ª–æ–∫" –∏ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –±–∞—Ä–æ–≤ */
            padding: max(20px, env(safe-area-inset-top)) max(20px, env(safe-area-inset-right)) max(20px, env(safe-area-inset-bottom)) max(20px, env(safe-area-inset-left));
        }

        .menu-title {
            font-family: 'Kelly Slab', serif;
            font-size: 8vmin;
            color: #ffd700;
            margin-bottom: 1vmin;
            text-shadow: 0 0 15px black, 0 4px 0 #8b4513;
            text-align: center;
            line-height: 1.1;
            z-index: 2;
            width: 100%;
        }

        .menu-subtitle {
            font-family: 'Kelly Slab', serif;
            font-size: 5vmin;
            color: #ffffff;
            margin-bottom: 2vmin;
            text-shadow: 2px 2px 4px black;
            text-align: center;
            z-index: 2;
        }

        .menu-desc {
            font-family: 'Comfortaa', cursive;
            font-size: 3vmin;
            color: #ddd;
            margin-bottom: 4vmin;
            max-width: 90%;
            text-shadow: 1px 1px 3px black;
            text-align: center;
            background: rgba(0,0,0,0.6);
            padding: 1.5vmin 3vmin;
            border-radius: 10px;
            z-index: 2;
        }

        h1 {
            font-family: 'Kelly Slab', serif;
            font-size: 6vmin;
            color: #ffd700;
            margin-bottom: 3vmin;
            text-shadow: 0.5vmin 0.5vmin 0 #8b4513;
        }

        .btn {
            background: linear-gradient(180deg, #e67e22 0%, #d35400 100%);
            border: 2px solid #fff;
            padding: 2vmin 5vmin;
            font-size: 3.5vmin; /* –ß—É—Ç—å –∫—Ä—É–ø–Ω–µ–µ –¥–ª—è –ø–∞–ª—å—Ü–µ–≤ */
            color: white;
            border-radius: 50px;
            cursor: pointer;
            margin: 1vmin;
            transition: transform 0.2s, box-shadow 0.2s;
            font-family: 'Comfortaa', cursive;
            box-shadow: 0 0.6vmin 0 #a04000, 0 1vmin 10px rgba(0,0,0,0.5);
            width: 90%; /* –®–∏—Ä–µ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö */
            max-width: 450px;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.5);
            z-index: 2;
            white-space: nowrap; /* –ß—Ç–æ–±—ã —Ç–µ–∫—Å—Ç –Ω–µ –µ—Ö–∞–ª */
        }

        .btn:hover {
            transform: scale(1.02) translateY(-2px);
            filter: brightness(1.1);
        }

        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 0.2vmin 0 #a04000;
        }

        .hidden {
            display: none !important;
        }

        .dialogue-box {
            position: relative;
            background: #fff8e1;
            color: #5d4037;
            padding: 4vmin;
            border: 0.8vmin solid #8b4513;
            border-radius: 20px;
            width: 95%; /* –®–∏—Ä–µ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö */
            max-width: 700px;
            font-size: 3.5vmin;
            pointer-events: all;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            margin-top: 2vmin;
            line-height: 1.4;
        }

        #current-goal {
            background: rgba(255, 215, 0, 0.2);
            padding: 5px 15px;
            border-radius: 10px;
            border: 1px solid gold;
            font-size: 3vmin;
        }
        
        #cur-hint {
             font-size: 4vmin;
        }

        /* --- –ê–¥–∞–ø—Ç–∏–≤–Ω–∞—è –≤—ë—Ä—Å—Ç–∫–∞ –ö–∞—Ç—Å—Ü–µ–Ω --- */
        .cutscene-layout {
            display: flex;
            flex-direction: column; /* –ú–æ–±–∏–ª—å–Ω—ã–π first: –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ */
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%; /* –°—Ç–∞—Ä–∞–µ–º—Å—è –∑–∞–Ω—è—Ç—å –≤—Å—é –≤—ã—Å–æ—Ç—É */
            gap: 2vh;
        }

        /* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∫–∞—Ä—Ç–∏–Ω–∫–∏ */
        .cutscene-img-block {
            width: 50vmin; /* –ö–≤–∞–¥—Ä–∞—Ç, –∑–∞–≤–∏—Å—è—â–∏–π –æ—Ç –º–∏–Ω. —Å—Ç–æ—Ä–æ–Ω—ã —ç–∫—Ä–∞–Ω–∞ */
            height: 50vmin;
            flex-shrink: 0; /* –ù–µ —Å–∂–∏–º–∞—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫—É */
            border: 0.8vmin solid #8b4513;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0,0,0,0.6);
            background: #000;
        }

        .cutscene-img-block img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* –¢–µ–∫—Å—Ç–æ–≤—ã–π –±–ª–æ–∫ */
        .cutscene-text-block {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 600px;
            flex-shrink: 1; 
        }

        /* –°–ø–µ—Ü–∏—Ñ–∏—á–Ω–æ –¥–ª—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–π –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ (–ª–∞–Ω–¥—à–∞—Ñ—Ç) */
        @media (orientation: landscape) {
            .cutscene-layout {
                flex-direction: row-reverse; /* –ö–∞—Ä—Ç–∏–Ω–∫–∞ —Å–ø—Ä–∞–≤–∞ */
                justify-content: center;
                align-items: center;
                gap: 5vw;
                padding: 0 5vw;
            }
            
            .cutscene-img-block {
                width: 45vh; /* –ü—Ä–∏–≤—è–∑–∫–∞ –∫ –≤—ã—Å–æ—Ç–µ —ç–∫—Ä–∞–Ω–∞ */
                height: 45vh;
            }

            .cutscene-text-block {
                align-items: flex-start; /* –¢–µ–∫—Å—Ç —Å–ª–µ–≤–∞ */
                text-align: left;
            }
            
            .cutscene-text-block .dialogue-box {
                margin-top: 0;
                font-size: 3vmin; /* –ß—É—Ç—å –º–µ–Ω—å—à–µ —à—Ä–∏—Ñ—Ç –≤ –ª–∞–Ω–¥—à–∞—Ñ—Ç–µ */
            }
            
            .cutscene-text-block h1 {
                text-align: left;
                width: 100%;
                margin-top: 0;
            }
            
            .cutscene-text-block .btn {
                align-self: center;
            }
            
            /* –ú–µ–Ω—é –≤ –ª–∞–Ω–¥—à–∞—Ñ—Ç–µ */
            #menu {
                justify-content: flex-end; 
                padding-bottom: 5vh;
            }
        }

        /* –°–ø–µ—Ü–∏—Ñ–∏—á–Ω–æ –¥–ª—è –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–π –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ (–ø–æ—Ä—Ç—Ä–µ—Ç) */
        @media (orientation: portrait) {
            .cutscene-layout {
                justify-content: center; /* –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏ */
            }
            
            /* –ï—Å–ª–∏ —ç–∫—Ä–∞–Ω –æ—á–µ–Ω—å —É–∑–∫–∏–π/–≤—ã—Å–æ–∫–∏–π, –∫–∞—Ä—Ç–∏–Ω–∫—É –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å —á—É—Ç—å –±–æ–ª—å—à–µ */
            .cutscene-img-block {
                width: 60vw;
                height: 60vw;
                max-width: 300px;
                max-height: 300px;
            }
            
            /* –ú–µ–Ω—é –≤ –ø–æ—Ä—Ç—Ä–µ—Ç–µ - —Ü–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –∏–ª–∏ –ø—Ä–∏–±–∏–≤–∞–µ–º –∫ –Ω–∏–∑—É */
            #menu {
                justify-content: flex-end;
                padding-bottom: 15vh; /* –û—Ç—Å—Ç—É–ø —Å–Ω–∏–∑—É –ø–æ–¥ –ø–∞–ª—å—Ü—ã */
            }
            
            .menu-title {
                font-size: 9vw; /* –ö—Ä—É–ø–Ω–µ–µ –Ω–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–µ */
            }
        }

        /* –§–æ–Ω –º–µ–Ω—é */
        .menu-bg-container {
            position: fixed; /* Fixed —á—Ç–æ–±—ã –Ω–µ –¥–µ—Ä–≥–∞–ª—Å—è –ø—Ä–∏ —Å–∫—Ä–æ–ª–ª–µ (—Ö–æ—Ç—è —Å–∫—Ä–æ–ª–ª–∞ –Ω–µ—Ç) */
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: -1; 
        }
        
        .menu-bg-blur {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover;
            filter: blur(20px) brightness(0.5);
            transform: scale(1.1);
        }
        
        .menu-bg-main {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            object-fit: contain;
            object-position: center top; 
        }

        /* --- –ù–û–í–´–ô –î–ò–ó–ê–ô–ù –≠–ö–†–ê–ù–ê –ó–ê–ì–†–£–ó–ö–ò (–û–±–Ω–æ–≤–ª–µ–Ω) --- */
        #loading-screen {
            background: linear-gradient(180deg, #87CEEB 0%, #caf0f8 60%, #4facfe 100%);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            padding: 5vmin;
            overflow: hidden;
        }

        /* –°–æ–ª–Ω—Ü–µ */
        .sun {
            position: absolute;
            top: 5vh;
            right: 5vw;
            width: 12vmin;
            height: 12vmin;
            background: radial-gradient(circle, #ffd700 40%, rgba(255, 215, 0, 0.5) 70%, rgba(255, 215, 0, 0) 100%);
            border-radius: 50%;
            animation: sunPulse 4s infinite alternate;
            z-index: 1;
        }
        @keyframes sunPulse {
            from { transform: scale(1); opacity: 0.9; }
            to { transform: scale(1.1); opacity: 1; }
        }

        /* –û–±–ª–∞–∫–∞ */
        .cloud {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50px;
            animation: moveCloud linear infinite;
            z-index: 1;
        }
        .cloud::after { content: ''; position: absolute; background: inherit; border-radius: 50%; width: 50%; height: 150%; top: -50%; left: 15%; }
        .cloud::before { content: ''; position: absolute; background: inherit; border-radius: 50%; width: 40%; height: 120%; top: -40%; right: 15%; }
        .c1 { width: 18vmin; height: 5vmin; top: 10vh; left: -20vw; animation-duration: 45s; opacity: 0.95; }
        .c2 { width: 14vmin; height: 4vmin; top: 20vh; left: -10vw; animation-duration: 60s; animation-delay: 5s; opacity: 0.8; }
        .c3 { width: 10vmin; height: 3vmin; top: 5vh; left: -30vw; animation-duration: 80s; animation-delay: 15s; opacity: 0.7; }

        @keyframes moveCloud {
            0% { transform: translateX(-30vw); }
            100% { transform: translateX(130vw); }
        }

        /* –û—Å—Ç—Ä–æ–≤–∞ —Å –ø–∞–ª—å–º–∞–º–∏ */
        .island {
            position: absolute;
            background: #d4a76a;
            border-radius: 60% 60% 0 0;
            bottom: 25vh; /* –ü–æ–¥–Ω–∏–º–∞–µ–º –æ—Å—Ç—Ä–æ–≤–∞ –≤—ã—à–µ —É—Ä–æ–≤–Ω—è –≤–æ–¥—ã */
            z-index: 2; /* –ó–∞ –∫–æ—Ä–∞–±–ª–µ–º –∏ –≤–æ–ª–Ω–∞–º–∏ */
            box-shadow: inset -5px 0 10px rgba(0,0,0,0.2);
        }
        .island-1 {
            width: 25vmin;
            height: 12vmin;
            left: 5vw;
        }
        .island-2 {
            width: 35vmin;
            height: 15vmin;
            right: 5vw;
            bottom: 27vh;
            background: #c59b60;
        }

        /* –ü–∞–ª—å–º–∞ */
        .palm {
            position: absolute;
            bottom: 85%;
            left: 50%;
            width: 1.5vmin;
            height: 10vmin;
            background: #8b4513;
            border-radius: 50% 50% 0 0;
            transform-origin: bottom center;
            transform: rotate(-10deg);
        }
        .palm-leaves {
            position: absolute;
            top: -6vmin;
            left: -8vmin;
            width: 16vmin;
            height: 8vmin;
        }
        .leaf {
            position: absolute;
            width: 8vmin;
            height: 2.5vmin;
            background: #2ecc71;
            border-radius: 50% 0 50% 0;
            top: 50%;
            left: 50%;
            transform-origin: 0 50%;
        }
        .l1 { transform: rotate(-40deg); }
        .l2 { transform: rotate(0deg); }
        .l3 { transform: rotate(140deg); background: #27ae60; }
        .l4 { transform: rotate(190deg); background: #27ae60; }

        /* –ö–æ—Ä–∞–±–ª–∏–∫ */
        .ship-container {
            position: absolute;
            bottom: 18vh; /* –ü–æ–∑–∏—Ü–∏—è –º–µ–∂–¥—É –≤–æ–ª–Ω–∞–º–∏ */
            left: 50%;
            width: 16vmin;
            height: 16vmin;
            transform: translateX(-50%);
            z-index: 4; /* –ú–µ–∂–¥—É –≤–æ–ª–Ω–∞–º–∏ */
            animation: shipBob 4s ease-in-out infinite;
        }
        .ship-hull {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 35%;
            background: #5d4037;
            border-radius: 5% 5% 45% 45%; 
            box-shadow: inset 0 -5px 10px rgba(0,0,0,0.3);
        }
        .ship-stripe {
            position: absolute;
            top: 15%;
            left: 0;
            width: 100%;
            height: 15%;
            background: #8d6e63;
        }
        .ship-mast-main {
            position: absolute;
            bottom: 30%;
            left: 48%;
            width: 4%;
            height: 60%;
            background: #3e2723;
        }
        .ship-sail-main {
            position: absolute;
            bottom: 45%;
            left: 52%;
            width: 40%;
            height: 40%;
            background: #fdfefe;
            border-radius: 0 50% 50% 5%;
            box-shadow: inset -2px 0 5px rgba(0,0,0,0.1);
            transform: skewX(-5deg);
        }
        .ship-flag {
            position: absolute;
            top: 10%;
            left: 52%;
            width: 20%;
            height: 10%;
            background: #d32f2f;
            clip-path: polygon(0 0, 100% 50%, 0 100%);
            animation: flagWave 1s ease-in-out infinite alternate;
        }

        @keyframes shipBob {
            0% { transform: translateX(-50%) translateY(0) rotate(1deg); }
            50% { transform: translateX(-50%) translateY(2vmin) rotate(-1deg); }
            100% { transform: translateX(-50%) translateY(0) rotate(1deg); }
        }
        @keyframes flagWave {
            from { transform: scaleX(1); }
            to { transform: scaleX(0.9); }
        }

        /* –û–∫–µ–∞–Ω - –°–ª–æ–∏ –Ω–∞—Ç—É—Ä–∞–ª—å–Ω–æ–π –≤–æ–¥—ã */
        .ocean {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 35vh; /* –ó–∞–Ω–∏–º–∞–µ—Ç –Ω–∏–∂–Ω–∏–µ 35% —ç–∫—Ä–∞–Ω–∞ */
            overflow: hidden;
            z-index: 3;
            pointer-events: none;
        }

        .wave {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 200%;
            height: 100%;
            background-repeat: repeat-x;
            background-size: 50% 100%;
            transform: translate3d(0, 0, 0);
        }

        /* SVG –≤–æ–ª–Ω—ã —Ä–∞–∑–Ω—ã—Ö —Ü–≤–µ—Ç–æ–≤ –¥–ª—è –≥–ª—É–±–∏–Ω—ã */
        .w1 {
            /* –¢–µ–º–Ω–æ-—Å–∏–Ω—è—è (–¥–∞–ª—å–Ω—è—è) */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 800 88.7'%3E%3Cpath d='M800 56.9c-155.5 0-204.9-50-405.5-49.9-200 0-250 49.9-394.5 49.9v31.8h800v-.2-31.6z' fill='%231e3c72'/%3E%3C/svg%3E");
            z-index: 3;
            animation: waveMove 20s linear infinite;
            height: 30vh;
            bottom: 0;
            opacity: 1;
        }
        
        .w2 {
             /* –°—Ä–µ–¥–Ω—è—è (–°–∏–Ω—è—è) */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 800 88.7'%3E%3Cpath d='M800 56.9c-155.5 0-204.9-50-405.5-49.9-200 0-250 49.9-394.5 49.9v31.8h800v-.2-31.6z' fill='%232a5298'/%3E%3C/svg%3E");
            z-index: 5; /* –ü–µ—Ä–µ–¥ –∫–æ—Ä–∞–±–ª–µ–º */
            animation: waveMove 15s linear infinite reverse;
            height: 20vh;
            bottom: 0;
            opacity: 0.9;
        }

        .w3 {
            /* –°–≤–µ—Ç–ª–∞—è (–±–ª–∏–∂–Ω—è—è) */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 800 88.7'%3E%3Cpath d='M800 56.9c-155.5 0-204.9-50-405.5-49.9-200 0-250 49.9-394.5 49.9v31.8h800v-.2-31.6z' fill='%234facfe'/%3E%3C/svg%3E");
            z-index: 6;
            animation: waveMove 8s linear infinite;
            height: 10vh;
            bottom: -1vh;
            opacity: 0.95;
        }

        @keyframes waveMove {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        /* –ö–æ–Ω—Ç–µ–Ω—Ç –∑–∞–≥—Ä—É–∑–∫–∏ */
        .loading-content {
            position: relative;
            z-index: 20;
            background: #fff8e1; /* –¶–≤–µ—Ç –ø–µ—Ä–≥–∞–º–µ–Ω—Ç–∞ */
            padding: 4vmin;
            border-radius: 15px;
            border: 3px solid #8b4513;
            max-width: 800px;
            width: 90%;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            text-align: left;
            margin-top: -20vmin; /* –ü–æ–¥–Ω–∏–º–∞–µ–º –ø–æ–≤—ã—à–µ */
        }

        /* --- –≠–§–§–ï–ö–¢ –ü–ï–°–ß–ê–ù–û–ì–û –¢–ï–ö–°–¢–ê --- */
        #loading-text, .dialogue-text-sand {
            font-family: 'Comfortaa', cursive; 
            font-size: 2.8vmin;
            font-weight: bold;
            line-height: 1.5;
            min-height: 12vmin;
            color: #5d4037;
        }

        .sand-word {
            display: inline-block;
            margin-right: 0.3em;
            opacity: 0;
            animation: sandForm 1.5s ease-out forwards;
        }

        @keyframes sandForm {
            0% {
                opacity: 0;
                transform: translateY(10px) scale(1.5);
                filter: blur(8px);
                color: #e6c288;
                text-shadow: 0 0 20px #e6c288;
            }
            60% {
                opacity: 1;
                filter: blur(2px);
                color: #bcaaa4;
                text-shadow: 0 0 5px #e6c288;
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
                filter: blur(0);
                color: #5d4037;
                text-shadow: none;
            }
        }

        #loading-continue-btn {
            opacity: 0;
            transition: opacity 1s;
            margin: 2vmin auto 0;
            display: block;
            background: linear-gradient(180deg, #27ae60 0%, #2ecc71 100%);
            box-shadow: 0 0.6vmin 0 #1e8449;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div class="ui-overlay">
        <div class="top-bar">
            <div id="alphabet-ui" class="alphabet-progress"></div>
            <div class="right-controls">
                <div id="lives-ui" class="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                <button class="pause-btn" onclick="togglePause()">–ü–∞—É–∑–∞</button>
            </div>
        </div>
    </div>

    <!-- –≠–ö–†–ê–ù –ó–ê–ì–†–£–ó–ö–ò / –ö–†–ê–°–û–ß–ù–´–ô -->
    <div id="loading-screen" class="overlay-screen" onclick="skipTypewriter()">
        <!-- –ê—Ç–º–æ—Å—Ñ–µ—Ä–∞ -->
        <div class="sun"></div>
        <div class="cloud c1"></div>
        <div class="cloud c2"></div>
        <div class="cloud c3"></div>

        <!-- –û—Å—Ç—Ä–æ–≤–∞ (–Ω–∞ –≥–æ—Ä–∏–∑–æ–Ω—Ç–µ) -->
        <div class="island island-1">
            <div class="palm"><div class="palm-leaves"><div class="leaf l1"></div><div class="leaf l2"></div><div class="leaf l3"></div><div class="leaf l4"></div></div></div>
        </div>
        <div class="island island-2"></div>

        <!-- –ö–æ—Ä–∞–±–ª–∏–∫ (–º–µ–∂–¥—É –≤–æ–ª–Ω–∞–º–∏) -->
        <div class="ship-container">
            <div class="ship-mast-main">
                <div class="ship-flag"></div>
            </div>
            <div class="ship-sail-main"></div>
            <div class="ship-hull">
                <div class="ship-stripe"></div>
            </div>
        </div>
        
        <!-- –û–∫–µ–∞–Ω (—Å–ª–æ–∏ –Ω–∞—Ç—É—Ä–∞–ª—å–Ω–æ–π –≤–æ–¥—ã) -->
        <div class="ocean">
            <div class="wave w1"></div> <!-- –î–∞–ª—å–Ω—è—è (–¢–µ–º–Ω–∞—è) -->
            <div class="wave w2"></div> <!-- –°—Ä–µ–¥–Ω—è—è -->
            <div class="wave w3"></div> <!-- –ë–ª–∏–∂–Ω—è—è (–°–≤–µ—Ç–ª–∞—è) -->
        </div>

        <!-- –ö–æ–Ω—Ç–µ–Ω—Ç (—Ç–µ–∫—Å—Ç –ø–æ—è–≤–ª—è–µ—Ç—Å—è "–∏–∑ –ø–µ—Å–∫–∞") -->
        <div class="loading-content">
            <div style="font-family: 'Kelly Slab'; font-size: 4vmin; color: #d35400; margin-bottom: 1vmin; text-align: center;">üìú –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø—Ä–æ–µ–∫—Ç–µ</div>
            <div id="loading-text"></div>
            <button id="loading-continue-btn" class="btn" onclick="enterMenu()">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
        </div>
    </div>

    <!-- –ì–ª–∞–≤–Ω–æ–µ –ú–µ–Ω—é -->
    <div id="menu" class="overlay-screen hidden" style="background: none;">
        
        <div class="menu-bg-container">
            <img id="menu-bg-blur" src="pirate_cover.jpg" 
                 onerror="this.style.display='none';" 
                 class="menu-bg-blur">
            <img id="menu-bg-main" src="pirate_cover.jpg" 
                 onerror="this.style.display='none'; document.getElementById('menu-fallback-bg').style.display='flex';" 
                 class="menu-bg-main">
            <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, rgba(0,0,0,0) 0%, rgba(0,0,0,0.1) 60%, rgba(0,0,0,0.9) 100%); pointer-events: none;"></div>
            <div id="menu-fallback-bg" style="display:none; width: 100%; height: 100%; background: #1a0a00; align-items: center; justify-content: center; color: #777; flex-direction: column;">
                <div style="font-size: 5vmin;">üè¥‚Äç‚ò†Ô∏è</div>
                <div>–î–æ–±–∞–≤—å—Ç–µ —Ñ–∞–π–ª pirate_cover.jpg</div>
            </div>
        </div>

        <!-- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –º–µ–Ω—é, —á—Ç–æ–±—ã –æ–Ω –≤—Å–µ–≥–¥–∞ –±—ã–ª –≤–Ω–∏–∑—É, –Ω–æ –Ω–µ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞–ª—Å—è -->
        <div style="margin-top: auto; width: 100%; display: flex; flex-direction: column; align-items: center;">
            <div class="menu-title">–ü—Ä–∏–∫–ª—é—á–µ–Ω–∏—è —é–Ω–æ–≥–æ<br>–ø–∏—Ä–∞—Ç–∞ –ß–∏–±–∏–∫–∞</div>
            <div class="menu-subtitle">–ì–ª–∞–≤–∞ 1. –î–µ–º–æ —É—Ä–æ–≤–µ–Ω—å</div>
            <div class="menu-desc">–û–±—É—á–∞—é—â–∞—è –∏–≥—Ä–∞ –¥–ª—è –¥–µ—Ç–µ–π –¥–æ—à–∫–æ–ª—å–Ω–æ–≥–æ –∏ –º–ª–∞–¥—à–µ–≥–æ —à–∫–æ–ª—å–Ω–æ–≥–æ –≤–æ–∑—Ä–∞—Å—Ç–∞</div>
            
            <div style="display: flex; flex-direction: column; align-items: center; gap: 1.5vmin; width: 100%; padding-bottom: 2vh;">
                <button class="btn" onclick="startGame('very_easy')">–û—á–µ–Ω—å –ª–µ–≥–∫–∏–π (–ø–æ–¥—Å–∫–∞–∑–∫–∏)</button>
                <button class="btn" onclick="startGame('easy')">–õ–µ–≥–∫–∏–π (3 –∂–∏–∑–Ω–∏)</button>
                <button class="btn" onclick="startGame('normal')">–ù–æ—Ä–º–∞–ª—å–Ω—ã–π (1 –∂–∏–∑–Ω—å)</button>
            </div>
        </div>
    </div>

    <!-- –ö–∞—Ç—Å—Ü–µ–Ω–∞ 1: –õ–µ–≥–µ–Ω–¥–∞ -->
    <div id="cutscene1" class="overlay-screen hidden" style="background: linear-gradient(135deg, #2c3e50 0%, #000000 100%);">
        <div class="cutscene-layout">
            <div class="cutscene-img-block">
                <img src="catscen1.jpg" alt="–°—Ç–∞—Ä–µ—Ü —Ä–∞—Å—Å–∫–∞–∑—ã–≤–∞–µ—Ç –ª–µ–≥–µ–Ω–¥—É" 
                     onerror="this.parentElement.style.background='#34495e'; this.style.display='none'; this.parentElement.innerHTML='<div style=\'color:#fff;display:flex;align-items:center;justify-content:center;height:100%;text-align:center;padding:10px;\'>–ù—É–∂–Ω–∞ –∫–∞—Ä—Ç–∏–Ω–∫–∞ catscen1.jpg</div>'">
            </div>
            <div class="cutscene-text-block">
                <h1>–õ–µ–≥–µ–Ω–¥–∞ –æ –§—Ä–µ–≥–∞—Ç–µ</h1>
                <div class="dialogue-box" style="margin-bottom: 3vmin;">
                    <p id="cs1-text">–°—Ç–∞—Ä–µ—Ü –æ—Ç—à–µ–ª—å–Ω–∏–∫ —Ä–∞—Å—Å–∫–∞–∑–∞–ª –Ω–∞—à–µ–º—É —é–Ω–æ–º—É –ß–∏–±–∏–∫—É, —á—Ç–æ –ø—Ä–æ–π–¥—è –ø–µ—â–µ—Ä—É –∏ –∏—Å–ø—ã—Ç–∞–Ω–∏—è –≤ –Ω–µ–π, –æ–Ω –Ω–∞–π–¥—ë—Ç —Å–∫—Ä—ã—Ç—ã–π –≥—Ä–æ—Ç, –≥–¥–µ –±—É–¥–µ—Ç –ù–∞—Å—Ç–æ—è—â–∏–π –ø–∏—Ä–∞—Ç—Å–∫–∏–π —Ñ—Ä–µ–≥–∞—Ç!</p>
                </div>
                <button class="btn" onclick="showCutscene2()">–î–∞–ª–µ–µ ‚û°</button>
            </div>
        </div>
    </div>

    <!-- –ö–∞—Ç—Å—Ü–µ–Ω–∞ 2: –ü–ª–∞–Ω –¥–µ–π—Å—Ç–≤–∏–π -->
    <div id="cutscene2" class="overlay-screen hidden" style="background: linear-gradient(135deg, #8e44ad 0%, #2c3e50 100%);">
        <div class="cutscene-layout">
            <div class="cutscene-img-block">
                <img src="catscen2.jpg" alt="–õ–∞–≤–æ–≤–∞—è —Ä–µ–∫–∞"
                     onerror="this.parentElement.style.background='#512e5f'; this.style.display='none'; this.parentElement.innerHTML='<div style=\'color:#fff;display:flex;align-items:center;justify-content:center;height:100%;text-align:center;padding:10px;\'>–ù—É–∂–Ω–∞ –∫–∞—Ä—Ç–∏–Ω–∫–∞ catscen2.jpg</div>'">
            </div>
            <div class="cutscene-text-block">
                <div class="dialogue-box" style="margin-bottom: 3vmin;">
                    <p id="cs2-text">–î–∞, –∏—Å–ø—ã—Ç–∞–Ω–∏–µ –≤ –ø–µ—â–µ—Ä–µ –ø—Ä–µ–¥—Å—Ç–æ–∏—Ç –Ω–µ –ø—Ä–æ—Å—Ç–æ–µ, –Ω—É–∂–Ω–æ –ø—Ä–æ–ø–ª—ã—Ç—å –∫–∞–∫-—Ç–æ —á–µ—Ä–µ–∑ –æ–≥—Ä–æ–º–Ω—É—é —Ä–µ–∫—É –ª–∞–≤—ã, –≤–¥–æ–ª—å –æ–≥—Ä–æ–º–Ω—ã—Ö —Å–∫–∞–ª–∏—Å—Ç—ã—Ö –±–µ—Ä–µ–≥–æ–≤... –Ω—É –ø–æ–ø—Ä–æ–±—É–µ–º —ç—Ç–æ —Å–¥–µ–ª–∞—Ç—å –ø–æ –∫–∞–º–Ω—è–º.. —Ç–∞–∫, –º—ã –≤–∏–¥–∏–º —á—Ç–æ –µ—Å—Ç—å –∫–∞–º–Ω–∏ –ø–ª—ã–≤—É—â–∏–µ –Ω–∞–∏–±–æ–ª–µ–µ —É—Å—Ç–æ–π—á–∏–≤–æ, –ø–æ–ø—Ä–æ–±—É–µ–º –ø—Ä–æ–ø—Ä—ã–≥–∞—Ç—å –ø–æ –Ω–∏–º.</p>
                    <p style="text-align: center; font-weight: bold; font-size: 1.2em; color: #d35400; margin-top: 10px; opacity: 0; animation: fadeInBtn 1s ease-out 5s forwards;">–í–ü–ï–†–Å–î!</p>
                </div>
                <button class="btn" style="background: linear-gradient(180deg, #27ae60 0%, #2ecc71 100%); box-shadow: 0 0.6vmin 0 #1e8449;" onclick="startLevelIntro()">–ù–ê–ß–ê–¢–¨</button>
            </div>
        </div>
    </div>

    <!-- –í—Å—Ç—É–ø–ª–µ–Ω–∏–µ -->
    <div id="intro" class="overlay-screen hidden">
        <div style="margin-top:auto; margin-bottom:auto; display: flex; flex-direction: column; align-items: center; width: 100%;">
            <h1>–ì–ª–∞–≤–∞ 1: –ü–µ—Ä–≤–æ–µ –∏—Å–ø—ã—Ç–∞–Ω–∏–µ! –°–∫–≤–æ–∑—å –õ–∞–≤—É!</h1>
            <div class="dialogue-box">
                <p><strong>–ß–∏–±–∏–∫:</strong> "–û–≥–æ, –∫–∞–∫–æ–µ –±—ã—Å—Ç—Ä–æ–µ —Ç–µ—á–µ–Ω–∏–µ! –ë–µ—Ä–µ–≥ –ø—Ä–æ–Ω–æ—Å–∏—Ç—Å—è –º–∏–º–æ. –ú–Ω–µ –Ω—É–∂–Ω–æ –Ω–∞–π—Ç–∏ –±—É–∫–≤—É <b id="intro-letter" style="color:red">–ê</b>. –ë–µ—Ä–µ–≥–∏—Å—å —Å–∫–∞–ª –ø–æ –∫—Ä–∞—è–º!"</p>
                <button class="btn" onclick="startLevel()">–ù–∞—á–∞—Ç—å –∑–∞–ø–ª—ã–≤!</button>
            </div>
        </div>
    </div>

    <!-- –ü–∞—É–∑–∞ -->
    <div id="pause-screen" class="overlay-screen hidden">
        <h1>–ü–∞—É–∑–∞</h1>
        <div class="dialogue-box">
            <p>–ò–≥—Ä–∞ –ø—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞.</p>
            <button class="btn" onclick="togglePause()">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
            <button class="btn" style="background:#d32f2f;" onclick="resetGame()">–í –º–µ–Ω—é</button>
        </div>
    </div>

    <!-- –ò–≥—Ä–∞ –û–∫–æ–Ω—á–µ–Ω–∞ -->
    <div id="game-over" class="overlay-screen hidden">
        <h1>–û –Ω–µ—Ç!</h1>
        <div class="dialogue-box">
            <p id="game-over-reason">–ü—Ä–∏—á–∏–Ω–∞ –ø—Ä–æ–∏–≥—Ä—ã—à–∞...</p>
            <button class="btn" onclick="resetGame()">–ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞</button>
        </div>
    </div>

    <!-- –§–∏–Ω–∞–ª -->
    <div id="outro" class="overlay-screen hidden">
        <h1>–ö–æ—Ä–∞–±–ª—å –≤ –ì—Ä–æ—Ç–µ!</h1>
        <div class="dialogue-box">
            <p><strong>–ú—É–¥—Ä—ã–π –û—Ç—à–µ–ª—å–Ω–∏–∫:</strong> "–¢—ã –≤–∏—Ä—Ç—É–æ–∑–Ω–æ —Å–ø—Ä–∞–≤–∏–ª—Å—è —Å —Ç–µ—á–µ–Ω–∏–µ–º –∏ –≤—ã—É—á–∏–ª –≤–µ—Å—å –∞–ª—Ñ–∞–≤–∏—Ç, –Æ–Ω—ã–π –ü–∏—Ä–∞—Ç! –¢–≤–æ–π –Ω–æ–≤—ã–π –∫–æ—Ä–∞–±–ª—å –≥–æ—Ç–æ–≤ –∫ –æ—Ç–ø–ª—ã—Ç–∏—é."</p>
            <div id="ai-victory-speech" style="font-style: italic; color: #5d4037; font-size: 0.9em; margin-bottom: 10px;"></div>
            <button class="btn" onclick="resetGame()">–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –Ω–∞—á–∞–ª–æ</button>
        </div>
    </div>
</div>

<script>
    const apiKey = ""; // Gemini API Key
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const alphabet = "–ê–ë–í–ì–î–ï–Å–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø".split("");
    
    // --- GEMINI AI FUNCTIONS ---
    async function callGemini(promptText) {
        if (!apiKey) return null;
        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contents: [{ parts: [{ text: promptText }] }] })
            });
            if (!response.ok) throw new Error('API Error');
            const data = await response.json();
            return data.candidates?.[0]?.content?.parts?.[0]?.text;
        } catch (error) {
            console.error(error);
            return null;
        }
    }

    async function generatePiratePraise(letter) {
        const fallbacks = ["–û—Ç–ª–∏—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞!", "–ú–æ–ª–æ–¥–µ—Ü!", "–¢–∞–∫ –¥–µ—Ä–∂–∞—Ç—å!", "–ü–æ–ª–Ω—ã–π –≤–ø–µ—Ä—ë–¥!", "–ï—â—ë –æ–¥–Ω—É –Ω–∞—à–ª–∏!"];
        const fallback = fallbacks[Math.floor(Math.random() * fallbacks.length)];
        const prompt = `–ü—Ä–µ–¥—Å—Ç–∞–≤—å, —á—Ç–æ —Ç—ã –≤–µ—Å–µ–ª—ã–π –ø–∏—Ä–∞—Ç –ß–∏–±–∏–∫ –∏–∑ –¥–µ—Ç—Å–∫–æ–π –∏–≥—Ä—ã. –†–µ–±–µ–Ω–æ–∫ –Ω–∞—à–µ–ª –±—É–∫–≤—É "${letter}". –ü—Ä–∏–¥—É–º–∞–π –æ—á–µ–Ω—å –∫–æ—Ä–æ—Ç–∫—É—é (2-4 —Å–ª–æ–≤–∞), –≤–µ—Å–µ–ª—É—é –∏ –æ–±–æ–¥—Ä—è—é—â—É—é —Ñ—Ä–∞–∑—É –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ. –ü–∏—Ä–∞—Ç—Å–∫–∏–π —Å—Ç–∏–ª—å, –ø–æ-–¥–æ–±—Ä–æ–º—É.`;
        pirate.currentPhrase = "–•–º..."; 
        const aiResponse = await callGemini(prompt);
        if (aiResponse) {
            pirate.currentPhrase = aiResponse.replace(/["¬´¬ª]/g, '').trim(); 
            pirate.phraseDuration = 3000; 
        } else {
            pirate.currentPhrase = fallback;
            pirate.phraseDuration = 2000;
        }
    }

    async function generateVictorySpeech() {
        const container = document.getElementById('ai-victory-speech');
        container.textContent = "–ß–∏–±–∏–∫ –ø–∏—à–µ—Ç —Å—É–¥–æ–≤–æ–π –∂—É—Ä–Ω–∞–ª...";
        const prompt = "–ù–∞–ø–∏—à–∏ –∫–æ—Ä–æ—Ç–∫–æ–µ (1-2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è) –≤–¥–æ—Ö–Ω–æ–≤–ª—è—é—â–µ–µ –ø–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è —Ä–µ–±–µ–Ω–∫–∞, –≤—ã—É—á–∏–≤—à–µ–≥–æ –∞–ª—Ñ–∞–≤–∏—Ç –≤ –∏–≥—Ä–µ –ø—Ä–æ –ø–∏—Ä–∞—Ç–æ–≤. –°—Ç–∏–ª—å: –¥–æ–±—Ä—ã–π –º—É–¥—Ä—ã–π –∫–∞–ø–∏—Ç–∞–Ω.";
        const aiResponse = await callGemini(prompt);
        if (aiResponse) {
            container.textContent = `"${aiResponse}"`;
        } else {
            container.textContent = "–ê–ª—Ñ–∞–≤–∏—Ç –≤—ã—É—á–µ–Ω! –°–æ–∫—Ä–æ–≤–∏—â–∞ –∑–Ω–∞–Ω–∏–π —Ç–µ–ø–µ—Ä—å —Ç–≤–æ–∏!";
        }
    }
    // --- END AI FUNCTIONS ---

    let gameState = 'loading'; // –ù–∞—á–∏–Ω–∞–µ–º —Å —ç–∫—Ä–∞–Ω–∞ –∑–∞–≥—Ä—É–∑–∫–∏
    let difficulty = 'easy';
    let lives = 3;
    let currentLetterIdx = 0;
    let stones = [];
    let particles = [];
    let bubbles = [];
    
    const FLOW_X = -1.2;
    const FLOW_Y = 0.7;
    const SLOPE = -0.6; 
    
    let riverWidthHalf = 350;
    let globalScale = 1; 
    
    let pirate = { 
        x: 0, 
        y: 0, 
        onStone: null, 
        jumping: false, 
        jumpProgress: 0,
        bobOffset: 0,
        waveTimer: 0,
        waveType: 0,
        speechTimer: 200,
        currentPhrase: null,
        phraseDuration: 0
    };

    const phrases = [
        "–¢—ã –º–æ–ª–æ–¥–µ—Ü!", "–í–ø–µ—Ä—ë–¥!", "–¢–∞–∫ –¥–µ—Ä–∂–∞—Ç—å!", 
        "–°–≤–∏—Å—Ç–∞—Ç—å –≤—Å–µ—Ö –Ω–∞–≤–µ—Ä—Ö!", "–ú—ã —Å–º–æ–∂–µ–º!", 
        "–ï—â—ë –Ω–µ–º–Ω–æ–≥–æ!", "–£—Ä–∞!", "–ö —Å–æ–∫—Ä–æ–≤–∏—â–∞–º!", "–ü–æ–ª–Ω—ã–π –≤–ø–µ—Ä—ë–¥!"
    ];

    let frame = 0;
    let lastTime = performance.now();
    let spawnCooldown = 0;
    let shoreOffset = 0;

    // --- –õ–û–ì–ò–ö–ê –≠–ö–†–ê–ù–ê –ó–ê–ì–†–£–ó–ö–ò ---
    const loadingTextFull = "–î–æ–±—Ä–æ –ü–æ–∂–∞–ª–æ–≤–∞—Ç—å! –≠—Ç–æ –ø—Ä–æ—Ç–æ—Ç–∏–ø (MVP) –æ–¥–Ω–æ–≥–æ –∏–∑ —É—Ä–æ–≤–Ω–µ–π –Ω–∞—Ö–æ–¥—è—â–µ–π—Å—è –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ –û–±—É—á–∞—é—â–µ–π –ò–≥—Ä—ã –¥–ª—è –î–µ—Ç–µ–π, –≤ –¥–∞–Ω–Ω–æ–º —É—Ä–æ–≤–Ω–µ –†–µ–±—ë–Ω–æ–∫ –∏–≥—Ä–∞—é—á–∏ –∏–∑—É—á–∞–µ—Ç –∏ –∑–∞–ø–æ–º–∏–Ω–∞–µ—Ç –ê–ª—Ñ–∞–≤–∏—Ç. –¢–∞–∫ –∂–µ –≤ –∏–≥—Ä–µ –±—É–¥—É—Ç –∏–≥—Ä—ã –¥–ª—è –∏–∑—É—á–µ–Ω–∏—è –ë–∞–∑–æ–≤–æ–º—É –†—É—Å—Å–∫–æ–º—É –Ø–∑—ã–∫—É (–≥—Ä–∞–º–º–∞—Ç–∏–∫–∞ –∏ –ø—É–Ω–∫—Ç—É–∞—Ü–∏—è) –∏ –±–∞–∑–æ–≤–∞—è –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞.";
    
    // –ù–æ–≤–∞—è –ª–æ–≥–∏–∫–∞ –ø–æ—è–≤–ª–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–∞ "–∏–∑ –ø–µ—Å–∫–∞" –ø–æ —Å–ª–æ–≤–∞–º
    function playSandAnimation(elementId, text = null) {
        const container = document.getElementById(elementId);
        const content = text || container.textContent;
        container.innerHTML = ""; 
        
        const words = content.split(' ');
        
        words.forEach((word, index) => {
            const span = document.createElement('span');
            span.textContent = word + ' ';
            span.className = 'sand-word';
            span.style.animationDelay = `${index * 0.15}s`; 
            container.appendChild(span);
        });
    }

    function startSandEffect() {
        playSandAnimation('loading-text', loadingTextFull);
        setTimeout(() => {
            document.getElementById('loading-continue-btn').style.opacity = '1';
        }, loadingTextFull.split(' ').length * 150 + 500);
    }

    function skipTypewriter() {
        const spans = document.querySelectorAll('#loading-text .sand-word');
        spans.forEach(span => {
            span.style.animation = 'none';
            span.style.opacity = '1';
            span.style.filter = 'blur(0)';
            span.style.transform = 'none';
            span.style.color = '#5d4037';
            span.style.textShadow = 'none';
        });
        document.getElementById('loading-continue-btn').style.opacity = '1';
    }

    function enterMenu() {
        document.getElementById('loading-screen').classList.add('hidden');
        document.getElementById('menu').classList.remove('hidden');
        gameState = 'menu';
    }

    window.onload = function() {
        startSandEffect();
    };
    // ----------------------------

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const minDim = Math.min(canvas.width, canvas.height);
        globalScale = minDim / 800;
        if (globalScale < 0.6) globalScale = 0.6;
        if (globalScale > 1.2) globalScale = 1.2;
        riverWidthHalf = minDim * 0.45; 
        if (!pirate.onStone && gameState === 'menu') {
            pirate.x = canvas.width * 0.5;
            pirate.y = canvas.height * 0.5;
        }
    }

    window.addEventListener('resize', resize);
    resize();

    function togglePause() {
        if (gameState === 'playing') {
            gameState = 'paused';
            document.getElementById('pause-screen').classList.remove('hidden');
        } else if (gameState === 'paused') {
            gameState = 'playing';
            document.getElementById('pause-screen').classList.add('hidden');
        }
    }

    window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' || e.key.toLowerCase() === 'p') {
            togglePause();
        }
    });

    function initAlphabetUI() {
        const container = document.getElementById('alphabet-ui');
        container.innerHTML = '';
        if (difficulty === 'very_easy') {
            alphabet.forEach((l, i) => {
                const span = document.createElement('span');
                span.className = 'letter-slot';
                span.id = `l-${i}`;
                span.textContent = l;
                container.appendChild(span);
            });
        } else {
            container.innerHTML = '<span id="current-goal">–ò—â–µ–º –±—É–∫–≤—É: <b id="cur-hint" style="color:#ffd700;">–ê</b></span>';
        }
    }

    function updateLivesUI() {
        document.getElementById('lives-ui').textContent = '‚ù§Ô∏è'.repeat(lives);
        const hint = document.getElementById('cur-hint');
        if (hint) hint.textContent = alphabet[currentLetterIdx];
        const introHint = document.getElementById('intro-letter');
        if (introHint) introHint.textContent = alphabet[currentLetterIdx];
    }

    function startGame(diff) {
        difficulty = diff;
        lives = (diff === 'normal') ? 1 : 3;
        gameState = 'cutscene1'; 
        document.querySelectorAll('.overlay-screen').forEach(el => el.classList.add('hidden'));
        document.getElementById('cutscene1').classList.remove('hidden');
        updateLivesUI();
        initAlphabetUI();
        
        playSandAnimation('cs1-text');
    }

    function showCutscene2() {
        document.getElementById('cutscene1').classList.add('hidden');
        document.getElementById('cutscene2').classList.remove('hidden');
        gameState = 'cutscene2';
        
        playSandAnimation('cs2-text');
    }

    function startLevelIntro() {
        document.getElementById('cutscene2').classList.add('hidden');
        document.getElementById('intro').classList.remove('hidden');
        gameState = 'intro';
    }

    function startLevel() {
        gameState = 'playing';
        document.getElementById('intro').classList.add('hidden');
        currentLetterIdx = 0;
        stones = [];
        bubbles = [];
        spawnInitialStones();
        updateLivesUI();
        lastTime = performance.now();
    }

    function resetGame() {
        location.reload();
    }

    function getRiverCenterY(x) {
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        return SLOPE * (x - cx) + cy;
    }

    function isInRiver(x, y) {
        const centerY = getRiverCenterY(x);
        return Math.abs(y - centerY) < riverWidthHalf;
    }

    function drawLava() {
        const grad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        grad.addColorStop(0, '#ff9100'); 
        grad.addColorStop(0.5, '#ff3d00'); 
        grad.addColorStop(1, '#8e0000'); 
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.lineWidth = 3 * globalScale;
        const step = 60 * globalScale;
        const timeOffset = (frame * 2) % step;
        ctx.strokeStyle = 'rgba(255, 230, 100, 0.3)';
        const minC = -canvas.width * Math.abs(SLOPE) - 300;
        const maxC = canvas.height + 300;
        for (let c = minC; c < maxC; c += step) {
            let currentC = c + timeOffset;
            ctx.beginPath();
            let startDrawn = false;
            for (let x = -50; x <= canvas.width + 50; x += 30) {
                let baseX = x;
                let baseY = SLOPE * baseX + currentC;
                let wave = Math.sin(x * 0.05 + frame * 0.1) * (10 * globalScale);
                let drawY = baseY + wave;
                if (!startDrawn) {
                    ctx.moveTo(x, drawY);
                    startDrawn = true;
                } else {
                    ctx.lineTo(x, drawY);
                }
            }
            ctx.stroke();
        }
        ctx.globalCompositeOperation = 'overlay';
        ctx.fillStyle = 'rgba(255, 200, 50, 0.1)';
        ctx.fillRect(0,0, canvas.width, canvas.height);
        ctx.globalCompositeOperation = 'source-over';
        ctx.restore();
    }

    function drawShores() {
        ctx.fillStyle = '#3e2723'; 
        ctx.strokeStyle = '#5d4037';
        ctx.lineWidth = 8 * globalScale;
        const w = canvas.width;
        const h = canvas.height;
        const cx = w / 2;
        const cy = h / 2;
        const offset = riverWidthHalf;
        shoreOffset -= 2 * globalScale; 

        ctx.beginPath();
        ctx.moveTo(0, 0); 
        ctx.lineTo(w, 0); 
        let rightBankY = SLOPE * (w - cx) + cy - offset;
        ctx.lineTo(w, rightBankY);
        const segments = 40;
        for(let i = segments; i >= 0; i--) {
            let x = (w / segments) * i;
            let idealY = SLOPE * (x - cx) + cy - offset;
            let noiseX = x + shoreOffset; 
            let noise = (Math.sin(noiseX * 0.02) * 15 + Math.cos(noiseX * 0.05) * 10) * globalScale;
            ctx.lineTo(x, idealY + noise);
        }
        ctx.lineTo(0, SLOPE * (0 - cx) + cy - offset); 
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, h); 
        ctx.lineTo(w, h); 
        let rightBankBottomY = SLOPE * (w - cx) + cy + offset;
        ctx.lineTo(w, rightBankBottomY);
        for(let i = segments; i >= 0; i--) {
            let x = (w / segments) * i;
            let idealY = SLOPE * (x - cx) + cy + offset;
            let noiseX = x + shoreOffset + 1000;
            let noise = (Math.sin(noiseX * 0.02) * 15 + Math.cos(noiseX * 0.05) * 10) * globalScale;
            ctx.lineTo(x, idealY + noise);
        }
        ctx.lineTo(0, SLOPE * (0 - cx) + cy + offset);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }

    function drawBubbles() {
        if (Math.random() < 0.2) {
            let spawnX = Math.random() * canvas.width + 200;
            let centerY = getRiverCenterY(spawnX);
            let spawnY = centerY + (Math.random() - 0.5) * (riverWidthHalf * 1.8);
            bubbles.push({
                x: spawnX,
                y: spawnY,
                r: (3 + Math.random() * 6) * globalScale,
                speed: (2 + Math.random() * 4) * globalScale,
                life: 1.0
            });
        }
        for (let i = bubbles.length - 1; i >= 0; i--) {
            let b = bubbles[i];
            b.x += FLOW_X * b.speed;
            b.y += FLOW_Y * b.speed;
            b.life -= 0.01;
            if (b.life <= 0 || b.x < -50 || b.y > canvas.height + 50) {
                bubbles.splice(i, 1);
                continue;
            }
            let cy = getRiverCenterY(b.x);
            if (Math.abs(b.y - cy) < riverWidthHalf - 20) {
                ctx.fillStyle = `rgba(255, 255, 255, ${b.life * 0.5})`;
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    function spawnInitialStones() {
        const startStone = {
            x: canvas.width * 0.5,
            y: canvas.height * 0.5,
            char: "‚òÖ",
            width: 140 * globalScale,
            height: 70 * globalScale,
            speed: 1.0 * globalScale,
            standingTime: 0,
            sinkProgress: 0,
            isSinking: false,
            bobPhase: Math.random() * 10
        };
        stones.push(startStone);
        pirate.onStone = startStone;
        pirate.x = startStone.x;
        pirate.y = startStone.y;
        for(let i = 0; i < 12; i++) spawnStone(true);
    }

    function spawnStone(isInitial = false) {
        const safeThreshold = canvas.width * 0.35; 
        const hasCorrectOnScreen = stones.some(s => 
            s.char === alphabet[currentLetterIdx] && 
            !s.isSinking && 
            s.x > safeThreshold
        );
        let chance = hasCorrectOnScreen ? 0.4 : 1.0;
        let char;
        if (Math.random() < chance) {
            char = alphabet[currentLetterIdx];
        } else {
            let randIdx;
            do {
                randIdx = Math.floor(Math.random() * alphabet.length);
            } while (randIdx === currentLetterIdx);
            char = alphabet[randIdx];
        }
        let x, y;
        let tries = 0;
        do {
            if (isInitial) {
                x = Math.random() * canvas.width;
            } else {
                x = canvas.width + 50 + Math.random() * 150; 
            }
            let centerY = getRiverCenterY(x);
            y = centerY + (Math.random() - 0.5) * (riverWidthHalf * 1.6);
            tries++;
        } while (tries < 5);
        stones.push({
            x: x,
            y: y,
            char: char,
            width: 120 * globalScale,
            height: 60 * globalScale,
            speed: (0.5 + Math.random() * 0.5) * globalScale,
            standingTime: 0,
            sinkProgress: 0,
            isSinking: false,
            bobPhase: Math.random() * 10
        });
    }

    function updateGame(deltaTime) {
        pirate.waveTimer -= 1;
        if (pirate.waveTimer <= 0) {
            let r = Math.random();
            if (r < 0.5) pirate.waveType = 0;
            else if (r < 0.7) pirate.waveType = 1;
            else if (r < 0.9) pirate.waveType = 2;
            else pirate.waveType = 3;
            pirate.waveTimer = 60 + Math.random() * 120;
        }
        if (pirate.currentPhrase) {
            pirate.phraseDuration -= deltaTime;
            if (pirate.phraseDuration <= 0) {
                pirate.currentPhrase = null;
                pirate.speechTimer = 3000 + Math.random() * 4000;
            }
        } else {
            pirate.speechTimer -= deltaTime;
            if (pirate.speechTimer <= 0) {
                pirate.currentPhrase = phrases[Math.floor(Math.random() * phrases.length)];
                pirate.phraseDuration = 2000;
            }
        }
        spawnCooldown -= deltaTime;
        const needsRescue = pirate.onStone && pirate.onStone.standingTime > 2000;
        const safeThreshold = canvas.width * 0.35;
        const missingTarget = !stones.some(s => s.char === alphabet[currentLetterIdx] && !s.isSinking && s.x > safeThreshold);
        const maxStones = 20;
        if ((needsRescue || missingTarget) && spawnCooldown > 100) {
             spawnCooldown = 100; 
        }
        if (spawnCooldown <= 0 && stones.length < maxStones) {
            spawnStone();
            spawnCooldown = 500 + Math.random() * 500; 
        }
        for (let i = 0; i < stones.length; i++) {
            for (let j = i + 1; j < stones.length; j++) {
                let s1 = stones[i];
                let s2 = stones[j];
                let dx = s1.x - s2.x;
                let dy = s1.y - s2.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                let minDist = (s1.width + s2.width) * 0.45; 
                if (dist < minDist && dist > 0) {
                    let overlap = minDist - dist;
                    let nx = dx / dist;
                    let ny = dy / dist;
                    let pushFactor = 0.05 * globalScale; 
                    s1.x += nx * overlap * pushFactor;
                    s1.y += ny * overlap * pushFactor;
                    s2.x -= nx * overlap * pushFactor;
                    s2.y -= ny * overlap * pushFactor;
                }
            }
        }
        for (let i = stones.length - 1; i >= 0; i--) {
            let s = stones[i];
            s.x += FLOW_X * s.speed;
            s.y += FLOW_Y * s.speed;
            let bobY = Math.sin(frame * 0.05 + s.bobPhase) * (4 * globalScale);
            if (pirate.onStone === s && !pirate.jumping) {
                pirate.x = s.x;
                pirate.y = s.y + bobY - (20 * globalScale); 
                s.standingTime += deltaTime;
                if (s.standingTime > 9000) {
                    s.isSinking = true;
                    s.sinkProgress += deltaTime / 4000;
                    if (s.sinkProgress >= 1) gameOver("–ö–∞–º–µ–Ω—å —É—à—ë–ª –ø–æ–¥ –ª–∞–≤—É!");
                }
            }
            if (s.sinkProgress < 1) {
                ctx.save();
                ctx.translate(s.x, s.y + bobY);
                if (s.isSinking) {
                    ctx.translate(0, s.sinkProgress * 40 * globalScale);
                    ctx.globalAlpha = 1 - s.sinkProgress;
                }
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.beginPath();
                ctx.ellipse(10 * globalScale, 25 * globalScale, s.width/2.2, s.height/2.2, 0, 0, Math.PI*2);
                ctx.fill();
                const isTarget = (s.char === alphabet[currentLetterIdx]);
                let highlightThreshold = canvas.width * 0.35; 
                let isUpstreamSafe = s.x > highlightThreshold;
                let grad = ctx.createRadialGradient(-10 * globalScale, -10 * globalScale, 5 * globalScale, 0, 0, s.width/2);
                if (isTarget && difficulty === 'very_easy' && isUpstreamSafe) {
                    grad.addColorStop(0, '#fff176');
                    grad.addColorStop(1, '#fbc02d');
                } else {
                    grad.addColorStop(0, '#8d6e63');
                    grad.addColorStop(1, '#3e2723');
                }
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.ellipse(0, 0, s.width/2, s.height/2, 0, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${36 * globalScale}px Comfortaa`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(s.char, 0, 0);
                if (pirate.onStone === s) {
                    ctx.globalAlpha = 1.0;
                    if (s.standingTime > 6000 && !s.isSinking) {
                        ctx.save();
                        let pulse = 1 + Math.sin(frame * 0.2) * 0.1;
                        ctx.scale(pulse, pulse);
                        ctx.fillStyle = (frame % 20 < 10) ? '#ffeb3b' : '#ff5252'; 
                        ctx.font = `bold ${28 * globalScale}px Arial`;
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 3 * globalScale;
                        let warnX = -70 * globalScale / pulse;
                        let warnY = -40 * globalScale / pulse;
                        ctx.strokeText("!!!", warnX, warnY);
                        ctx.fillText("!!!", warnX, warnY);
                        ctx.restore();
                    }
                    if (s.isSinking) {
                        let timeLeft = Math.ceil(4 * (1 - s.sinkProgress));
                        if (timeLeft < 0) timeLeft = 0;
                        ctx.save();
                        let pulse = 1 + Math.sin(frame * 0.5) * 0.15;
                        ctx.scale(pulse, pulse);
                        ctx.fillStyle = '#ff1744'; 
                        ctx.font = `bold ${50 * globalScale}px Comfortaa`; 
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 5 * globalScale;
                        let timerX = -85 * globalScale / pulse;
                        let timerY = -30 * globalScale / pulse;
                        ctx.strokeText(timeLeft, timerX, timerY);
                        ctx.fillText(timeLeft, timerX, timerY);
                        ctx.restore();
                    }
                }
                ctx.restore();
            }
            if (s.x < -150 * globalScale || s.y > canvas.height + 150 * globalScale) {
                if (pirate.onStone === s) gameOver("–£–ø–ª—ã–ª —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ!");
                stones.splice(i, 1);
            }
        }
        updateParticles();
    }

    function checkJump(ex, ey) {
        if (gameState !== 'playing' || pirate.jumping) return;
        let bestStone = null;
        for (let s of stones) {
            let dx = ex - s.x;
            let dy = ey - s.y; 
            if ( (dx*dx)/((s.width/1.2)**2) + (dy*dy)/((s.height/1.2)**2) <= 1.2 ) { 
                bestStone = s;
                break; 
            }
        }
        if (bestStone && bestStone !== pirate.onStone) {
            pirate.jumping = true;
            pirate.jumpProgress = 0;
            pirate.jumpStartX = pirate.x;
            pirate.jumpStartY = pirate.y;
            if (bestStone.char === alphabet[currentLetterIdx]) {
                pirate.onStone = bestStone;
                currentLetterIdx++;
                createExplosion(bestStone.x, bestStone.y, '#ffd700');
                if (difficulty === 'very_easy') {
                     const el = document.getElementById(`l-${currentLetterIdx-1}`);
                     if (el) el.classList.add('active');
                }
                updateLivesUI();
                generatePiratePraise(bestStone.char);
                if (currentLetterIdx >= alphabet.length) {
                    setTimeout(() => {
                        win();
                        generateVictorySpeech(); 
                    }, 500);
                }
            } else {
                lives--;
                createExplosion(bestStone.x, bestStone.y, '#ff3d00');
                updateLivesUI();
                if (lives <= 0) setTimeout(() => gameOver("–ù–µ–≤–µ—Ä–Ω–∞—è –±—É–∫–≤–∞!"), 300);
                pirate.onStone = bestStone;
            }
        }
    }

    function drawPirate() {
        ctx.save();
        let dx = pirate.x;
        let dy = pirate.y;
        if (pirate.jumping) {
            pirate.jumpProgress += 0.08;
            if (pirate.jumpProgress >= 1) {
                pirate.jumping = false;
                pirate.jumpProgress = 0;
            } else {
                dy -= Math.sin(pirate.jumpProgress * Math.PI) * (100 * globalScale);
            }
        }
        ctx.translate(dx, dy);
        ctx.scale(globalScale, globalScale);
        if (!pirate.jumping) {
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(0, 20, 30, 15, 0, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.fillStyle = '#222'; 
        ctx.beginPath();
        ctx.ellipse(-10, 18, 6, 8, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(10, 18, 6, 8, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#e67e22'; 
        ctx.fillRect(-20, -15, 40, 35);
        ctx.fillStyle = '#c0392b';
        ctx.beginPath();
        ctx.moveTo(-20, -15);
        ctx.lineTo(0, 5);
        ctx.lineTo(20, -15);
        ctx.lineTo(0, -25);
        ctx.fill();
        ctx.fillStyle = '#ffdbac';
        ctx.beginPath();
        ctx.arc(0, -45, 35, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.moveTo(-50, -60);
        ctx.quadraticCurveTo(0, -110, 50, -60);
        ctx.lineTo(0, -50);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.font = '16px Arial';
        ctx.fillText('‚ò†', -8, -75);
        ctx.fillStyle = '#00bcd4';
        if (lives > 0) {
            if (Math.random() > 0.98) {
                 ctx.fillRect(-18, -48, 12, 4);
                 ctx.fillRect(6, -48, 12, 4);
            } else {
                ctx.beginPath();
                ctx.arc(-12, -45, 6, 0, Math.PI * 2);
                ctx.arc(12, -45, 6, 0, Math.PI * 2);
                ctx.fill();
            }
        } else {
            ctx.font = '20px Arial';
            ctx.fillText('x  x', -18, -40);
        }
        if (lives > 0) {
            ctx.strokeStyle = '#d84315';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, -32, 10, 0.2 * Math.PI, 0.8 * Math.PI);
            ctx.stroke();
        }
        if (pirate.currentPhrase && lives > 0) {
            ctx.save();
            ctx.translate(0, -90); 
            ctx.font = 'bold 16px Comfortaa';
            const textMetrics = ctx.measureText(pirate.currentPhrase);
            const bubbleWidth = textMetrics.width + 40;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.beginPath();
            ctx.roundRect(-bubbleWidth/2, -30, bubbleWidth, 30, 10);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(10, 10);
            ctx.lineTo(20, 0);
            ctx.fill();
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const displayText = apiKey ? `‚ú® ${pirate.currentPhrase}` : pirate.currentPhrase;
            ctx.fillText(displayText, 0, -15);
            ctx.restore();
        }
        ctx.save();
        ctx.translate(-18, -10);
        let leftAngle = 0.5;
        if (pirate.waveType === 1 || pirate.waveType === 3) {
            leftAngle = Math.PI + Math.sin(frame * 0.2) * 0.5;
        }
        ctx.rotate(leftAngle);
        ctx.fillStyle = '#e67e22'; 
        ctx.beginPath(); ctx.roundRect(-5, 0, 10, 20, 5); ctx.fill();
        ctx.fillStyle = '#ffdbac'; 
        ctx.beginPath(); ctx.arc(0, 20, 6, 0, Math.PI*2); ctx.fill();
        ctx.restore();
        ctx.save();
        ctx.translate(18, -10);
        let rightAngle = -0.5;
        if (pirate.waveType === 2 || pirate.waveType === 3) {
            rightAngle = -Math.PI - Math.sin(frame * 0.2 + 1) * 0.5; 
        }
        ctx.rotate(rightAngle);
        ctx.fillStyle = '#e67e22'; 
        ctx.beginPath(); ctx.roundRect(-5, 0, 10, 20, 5); ctx.fill();
        ctx.fillStyle = '#ffdbac'; 
        ctx.beginPath(); ctx.arc(0, 20, 6, 0, Math.PI*2); ctx.fill();
        ctx.restore();
        ctx.restore();
    }

    function createExplosion(x, y, color) {
        for(let i=0; i<15; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random()-0.5)*10 * globalScale,
                vy: (Math.random()-0.5)*10 * globalScale,
                life: 1.0,
                color: color
            });
        }
    }

    function updateParticles() {
        for(let i=particles.length-1; i>=0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.05;
            if(p.life <= 0) {
                particles.splice(i,1);
                continue;
            }
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 5 * globalScale, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    function gameOver(reason) {
        gameState = 'gameover';
        document.getElementById('game-over-reason').innerText = reason;
        document.querySelectorAll('.overlay-screen').forEach(el => el.classList.add('hidden'));
        document.getElementById('game-over').classList.remove('hidden');
    }

    function win() {
        gameState = 'outro';
        document.querySelectorAll('.overlay-screen').forEach(el => el.classList.add('hidden'));
        document.getElementById('outro').classList.remove('hidden');
    }

    function loop(time) {
        let dt = time - lastTime;
        lastTime = time;
        if (gameState !== 'paused') {
            frame++;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawLava();
            drawBubbles();
            drawShores();
            if (gameState === 'playing') {
                updateGame(dt);
                drawPirate();
            } else if (gameState === 'intro' || gameState === 'gameover' || gameState === 'outro') {
                // –§–æ–Ω
            }
        }
        requestAnimationFrame(loop);
    }

    canvas.addEventListener('mousedown', (e) => checkJump(e.clientX, e.clientY));
    canvas.addEventListener('touchstart', (e) => {
        checkJump(e.touches[0].clientX, e.touches[0].clientY);
    });

    requestAnimationFrame(loop);

</script>
</body>
</html>
